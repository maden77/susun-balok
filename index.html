<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stack Builder - PWA</title>
<link rel="manifest" href="manifest.json" />
<meta name="theme-color" content="#222" />
<link rel="icon" href="icons/icon2048-192x192.png" />
<style>
  body {
    margin: 0; font-family: sans-serif; background: #111; color: #fff; overflow: hidden;
  }
  #score {
    position: fixed; top: 10px; left: 10px; font-size: 20px; z-index: 10;
  }
  canvas {
    display: block; margin: 0 auto; background: #222; border: 2px solid #444;
    image-rendering: pixelated;
  }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="gameCanvas" width="320" height="480"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const blockSize = 32;
  const cols = canvas.width / blockSize; // 10
  const rows = canvas.height / blockSize; // 15
  let grid = Array(rows).fill(null).map(() => Array(cols).fill(0));
  let score = 0;

  let current = { x: Math.floor(cols / 2), y: 0, color: randomColor() };

  // Audio context for tone
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playTone(freq) {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.type = 'square';
    osc.frequency.value = freq;
    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.12);
  }

  function randomColor() {
    return `hsl(${Math.random()*360}, 70%, 60%)`;
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw stacked blocks
    for(let y=0; y<rows; y++) {
      for(let x=0; x<cols; x++) {
        if(grid[y][x]) {
          ctx.fillStyle = grid[y][x];
          ctx.fillRect(x*blockSize, y*blockSize, blockSize, blockSize);
          ctx.strokeStyle = '#333';
          ctx.strokeRect(x*blockSize, y*blockSize, blockSize, blockSize);
        }
      }
    }
    // Draw current falling block
    ctx.fillStyle = current.color;
    ctx.fillRect(current.x*blockSize, current.y*blockSize, blockSize, blockSize);
    ctx.strokeStyle = '#fff';
    ctx.strokeRect(current.x*blockSize, current.y*blockSize, blockSize, blockSize);
  }

  function placeBlock() {
    grid[current.y][current.x] = current.color;
    playTone(300 + current.y * 15);
  }

  function clearFullRows() {
    let rowsCleared = 0;
    for(let y = rows -1; y >=0; y--) {
      if(grid[y].every(c => c !== 0)) {
        grid.splice(y,1);
        grid.unshift(Array(cols).fill(0));
        rowsCleared++;
        y++; // check new row that shifted down
      }
    }
    if(rowsCleared > 0) {
      score += rowsCleared * 10;
      document.getElementById('score').textContent = 'Score: ' + score;
      playTone(800);
    }
  }

  function gameOverCheck() {
    for(let x=0; x<cols; x++) {
      if(grid[0][x] !== 0) return true;
    }
    return false;
  }

  function resetGame() {
    grid = Array(rows).fill(null).map(() => Array(cols).fill(0));
    score = 0;
    document.getElementById('score').textContent = 'Score: 0';
    current = { x: Math.floor(cols / 2), y: 0, color: randomColor() };
  }

  function tick() {
    current.y++;
    if(current.y >= rows || grid[current.y][current.x]) {
      current.y--;
      placeBlock();
      clearFullRows();
      if(gameOverCheck()) {
        alert('Game Over!\nSkor Anda: ' + score);
        resetGame();
      } else {
        current = { x: Math.floor(cols / 2), y: 0, color: randomColor() };
      }
    }
    draw();
  }

  window.addEventListener('keydown', e => {
    if(e.key === 'ArrowLeft') {
      if(current.x > 0 && !grid[current.y][current.x - 1]) {
        current.x--;
        draw();
      }
    } else if(e.key === 'ArrowRight') {
      if(current.x < cols - 1 && !grid[current.y][current.x + 1]) {
        current.x++;
        draw();
      }
    }
  });

  draw();
  setInterval(tick, 600);
</script>

<script>
  if('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
    .then(() => console.log('Service Worker registered'))
    .catch(console.error);
  }
</script>
</body>
</html>
